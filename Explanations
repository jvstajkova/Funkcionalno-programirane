Понеже днес не знам до колко стана ясно и до колко успях да обясня частичното прилагане на функциите,
ще го напиша още веднъж тук. Първо, когато се определя типът на дадена функция е хубаво да се има предвид,
че операторът -> е дясно асоциативен. Това означава, че ако f :: Int -> Int -> Int, то реално типът на f e f :: (Int -> (Int -> Int)).

Нека f e дефинира така: f a b = a + b. Тази дефиниция е еквивалентна на f a = (\ b -> a + b) и на f = (\ a -> (\ b -> a + b)).
На практика тази дясна асоциативност означава, че всяка функция в Хаскел има само един аргумент, 
тоест няма значение дали при оценката на израза ще запишем (f 1 2) или ((f 1) 2), те са еквивалентни.
Прилагането на функция към аргументи е ляво асоциативно, както се вижда и от примера.

Важно е да се отбележи, че (Int -> Int) -> Int не е същото като Int -> Int -> Int.
Изводът е, че ако трябва да решите задача, която връща функция от по-висок ред,
то можете да я разглеждате като функция на по-голям брой аргументи. 
Пример: типът на втората задача от домашното maximize :: [(Double -> Double)] -> (Double -> Double) 
е еквивалентен на maximize :: [(Double -> Double)] -> Double -> Double.
